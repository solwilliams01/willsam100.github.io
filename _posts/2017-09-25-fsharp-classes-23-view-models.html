---
layout: post
title: Everything you need to know about F# classes in 23 view models
date: 2017-09-25 08:21:57.000000000 +13:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- Class
- GUI
- Interfaces
- View Model
meta:
  _edit_last: '1'
  mashsb_timestamp: '1591365388'
  _yoast_wpseo_content_score: '30'
  mashsb_twitter_handle: willsam100
  _yoast_wpseo_primary_category: '47'
  _yoast_wpseo_focuskw_text_input: fsharp view models
  mashsb_shares: '4'
  mashsb_jsonshares: '{"total":4,"error":"","twitter":2,"facebook_shares":2,"facebook_total":0,"facebook_likes":0,"facebook_comments":0}'
  mashsb_shorturl: http://www.codingwithsam.com/fsharp-classes-23-view-models/
  _yoast_wpseo_focuskw: fsharp view models
  _yoast_wpseo_title: "%%title%% %%sep%% %%category%%"
  _yoast_wpseo_metadesc: View models make for a great way to learn the class features
    of F#. Here are 23 useless view models so you can build many more useful F# view
    models!
  _yoast_wpseo_linkdex: '68'
  dsq_thread_id: '6168821796'
author:
  login: sam
  email: willsam100@gmail.com
  display_name: Sam Williams
  first_name: Sam
  last_name: Williams
permalink: "/2017/09/25/fsharp-classes-23-view-models/"
---
<p>The View model is the centerpiece to MVVM, with no external dependencies. As a result, the view model is an excellent class that requires no libraries while also exercising many language features related to classes. These requirements make view models a great example for learning how to build classes in a new language.</p>
<p>If learning F# (FSharp) is on your bucket list, getting started with classes is the easiest. Everything you need to know about F# classes is covered here. This post shows 23 (mostly) useless view models to get you started with F#. At the end, you will know how to make any useful view model in F#, so let's get started!</p>
<h2>View Model: #1</h2>
<p>As already stated, in the purest sense, a view model is just a class. Creating classes in F# is really easy. Here is our first view model</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel1</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="fn">Foo</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="n">42</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>There is no need to create a new file. The only requirement is that it is declared before it is used.</p>
<p><code>type</code> is synonymous with the <code>class</code> keyword. <code>ViewModel</code> is also public by default, which is generally what the developer intended. Parenthesis follow the class name.</p>
<p><code>Foo</code> is a public method. They keyword <code>member</code> is used to declare anything that belongs to the class. Additionally don't forget the instance for the method <code>this.</code> required before the name of the method.</p>
<p>A few striking differences that immediately stand out to most developers is the lack of curly braces and types. The braces are omitted in favour of indentation. Should any problems arise with indentation, the compiler will highlight the line. Secondly, the lack of types can seam daunting. The F# compiler utilizes advanced mathematics so this generally not a problem. All items are given a type and checked for consistent usage. This is known as type inference.</p>
<h2>Variables: More than one way</h2>
<p>Variables are possible in F#, and the language even has two ways of doing it. An example of each is listed below:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel2</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="k">mutable</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="n">42</span>

<span class="k">type</span> <span class="rt">ViewModel3</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="fn">ref</span> <span class="n">42</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>A key aspect to highlight in the examples above is that mutation/variables require 'opt in' with keywords. By default, all items are immutable, which is what most developers prefer. <a href="//www.codingwithsam.com/predictable-code/">Predictable code</a> is the result of immutability.</p>
<p>Next up, our view model needs a getter to expose the variables.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel4</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="k">mutable</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="n">42</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> <span class="o">=</span> <span class="mv">_variable</span>

<span class="k">type</span> <span class="rt">ViewModel5</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="fn">ref</span> <span class="n">42</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> <span class="o">=</span> <span class="o">!</span><span class="mv">_variable</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>As with the methods, the <code>member</code> keyword is used, but the parentheses are left off. For the <code>ref</code> variable, note the <code>!</code> that is used to return the value contained. If this is missed, the wrong type will be returned. If a setter is also present (shown later), then a compiler error will result.</p>
<p>With the getters defined, a setter is is the next step. On a side note, in F# <code>&lt;-</code> is used for assignment. For the <code>ref</code> there is a shorthand <code>:=</code> to update the value.</p>
<p>Adding a setter to the property is simple and straight forward. Append the keyword <code>and</code> with <code>set</code> and then name the parameter to function, <code>value</code> is commonly used.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel6</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="k">mutable</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="n">42</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span>  
        <span class="k">with</span> <span class="prop">get</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="mv">_variable</span>
        <span class="k">and</span> <span class="prop">set</span><span class="pn">(</span><span class="id">value</span><span class="pn">)</span> <span class="o">=</span> <span class="mv">_variable</span> <span class="k">&lt;-</span> <span class="id">value</span> <span class="c">//Assignment in F#</span>

<span class="k">type</span> <span class="rt">ViewModel7</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="mv">_variable</span> <span class="o">=</span> <span class="fn">ref</span> <span class="n">42</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> 
        <span class="k">with</span> <span class="prop">get</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="o">!</span><span class="mv">_variable</span> <span class="c">// same as _variable.Value</span>
        <span class="k">and</span> <span class="prop">set</span><span class="pn">(</span><span class="id">value</span><span class="pn">)</span> <span class="o">=</span> <span class="mv">_variable</span> <span class="o">:=</span> <span class="id">value</span> <span class="c">//Same as `_variable.Value &lt;- value`</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2>When to use <code>mutable</code> or <code>ref</code></h2>
<p>You should prefer <code>mutable</code> over <code>ref</code> as it is easier to with. You can use <code>ref</code> when using a framework that updates the value of properties in a subclass. To illustrate this, here is our next view model:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel8</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">inherit</span> <span class="id">FrameworkViewModel</span><span class="pn">(</span><span class="pn">)</span>

    <span class="k">let</span> <span class="id">_variable</span> <span class="o">=</span> <span class="id">ref</span> <span class="n">42</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> 
        <span class="k">with</span> <span class="prop">get</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="o">!</span><span class="id">_variable</span>
        <span class="k">and</span> <span class="prop">set</span><span class="pn">(</span><span class="id">value</span><span class="pn">)</span> <span class="o">=</span> 
            <span class="k">if</span> <span class="pn">(</span><span class="id">this</span><span class="pn">.</span><span class="id">SetProperty</span><span class="pn">(</span><span class="id">_variable</span><span class="pn">,</span> <span class="id">value</span><span class="pn">)</span><span class="pn">)</span> <span class="k">then</span> 
                <span class="id">this</span><span class="pn">.</span><span class="id">RaisePropertyChanged</span><span class="pn">(</span><span class="s">"Foo"</span><span class="pn">)</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>They key part to the code above is the call to <code>SetProperty</code> a method on the base class. For a view model, there is no need to set a value if it has not changed. <code>SetProperty</code> performs this check, and then updates the value if value has changed. A bool, ie true, will be returned if the value is updated. A <code>ref</code> makes this possible.</p>
<h2>Auto Properties: A new keyword</h2>
<p>Auto properties have a backing variable. In F# the syntax is a little different to methods. Here is an example with a getter only</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel9</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="k">val</span> <span class="prop">Foo</span> <span class="o">=</span> <span class="n">42</span>

<span class="c">// Long form, prefer the above format if no setter</span>
<span class="k">type</span> <span class="rt">ViewModel10</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="k">val</span> <span class="prop">Foo</span> <span class="o">=</span> <span class="n">42</span> <span class="k">with</span> <span class="id">get</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>The key difference here is the use of the keyword <code>val</code>. Additionally the instance, <code>this</code> no longer needs to declared before the name.</p>
<p>Adding a setter is also super easy, just add a comma and the keyword <code>set</code>:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel11</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="k">val</span> <span class="prop">Foo</span> <span class="o">=</span> <span class="mv">42</span> <span class="k">with</span> <span class="id">get</span><span class="pn">,</span> <span class="id">set</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2>Scoping rules: There's a twist</h2>
<p>Scoping rules are also available in F#. Methods can have their usage restricted to only inside the class with <code>private</code>.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel12</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="k">private</span> <span class="id">this</span><span class="pn">.</span><span class="fn">Foo</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="n">42</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>There is no scoping for <code>protected</code> as it creates potential problems with lamda functions accessing the base class. Instead use interfaces/higher-order functions.</p>
<h2>Prefer function over methods</h2>
<p>It turns out there is another way to achieve the same as a private method in F#. A function declared in a class in most circumstances will behave the same as a private method. Because of this, it is best to prefer functions over methods, as functions have better type inference and can be chained together easier using F#'s iconic piper operator <code>|&gt;</code>.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel13</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="id">foo</span> <span class="o">=</span> <span class="n">42</span>
    <span class="k">let</span> <span class="fn">addTen</span> <span class="id">x</span> <span class="o">=</span> <span class="id">x</span> <span class="o">+</span> <span class="n">10</span>
    <span class="k">let</span> <span class="id">data</span> <span class="o">=</span> <span class="id">foo</span> <span class="o">|&gt;</span> <span class="fn">addTen</span> <span class="o">|&gt;</span> <span class="fn">string</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>Closely related to access modifiers, is overriding methods. It is also possible in F#, and is just a keyword change to use <code>override</code> instead of <code>member</code></p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel14</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">inherit</span> <span class="id">MvvmBase</span><span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">this</span><span class="pn">.</span><span class="fn">Foo</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="n">42</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2>Adding constructor arguments</h2>
<p>Constructor arguments, are passed within the parentheses of the declaring line of the class. See below:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel15</span><span class="pn">(</span><span class="id">foo</span><span class="pn">:</span> <span class="vt">int</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span><span class="pn">:</span> <span class="vt">int</span> <span class="o">=</span> <span class="id">foo</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>Types in F# are declared after the name with a colon. The type can also be omitted in many cases and F# will infer the type.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel16</span><span class="pn">(</span><span class="id">foo</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span><span class="pn">:</span> <span class="vt">int</span> <span class="o">=</span> <span class="id">foo</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>For this example, the method <code>Foo</code> has been declared to return an int. F# can figure out that the type of <code>foo</code> must also be an int. Alternatively, the type could be declared the other way around. The types and meaning are identical in both cases:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel17</span><span class="pn">(</span><span class="id">foo</span><span class="pn">:</span> <span class="vt">int</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> <span class="o">=</span> <span class="id">foo</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>Another important point to highlight with constructor arguments in F# is that they are immutable:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// Will not compile. Error: `This value is not mutable`</span>
<span class="k">type</span> <span class="rt">ViewModel18</span><span class="pn">(</span><span class="id">foo</span><span class="pn">:</span> <span class="vt">int</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="id">fooPlusTen</span> <span class="o">=</span> 
        <span class="id">foo</span> <span class="k">&lt;-</span> <span class="n">10</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>If immutability is a problem and mutation is required, there is a simple solution. A copy of the constructor argument can be taken and declared with the <code>mutable</code> keyword highlighted above (though many prefer to avoid mutation, as functional competence is gained).</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel19</span><span class="pn">(</span><span class="id">foo</span><span class="pn">:</span> <span class="vt">int</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="k">mutable</span> <span class="mv">_foo</span> <span class="o">=</span> <span class="id">foo</span>
    <span class="k">let</span> <span class="id">fooPlusTen</span> <span class="o">=</span> 
        <span class="mv">_foo</span> <span class="k">&lt;-</span> <span class="n">10</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2>A Constructor without a Constructor</h2>
<p>The syntax for constructors is a quite different in F#; though much cleaner. To declare a constructor, after the local functions/values and before any member items, <code>do</code> signals the constructor followed by the required statements.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel20</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> 

    <span class="k">let</span> <span class="k">mutable</span> <span class="mv">foo</span><span class="pn">:</span> <span class="rt">string</span> <span class="o">=</span> <span class="k">null</span>
    <span class="k">do</span> 
        <span class="mv">foo</span> <span class="k">&lt;-</span> <span class="s">"Hello, World"</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="fn">Foo</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="mv">foo</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>In the example above, the class is initially constructed with <code>foo</code> set to <code>null</code>. The constructor (the statements after <code>do</code>), are evaluated and <code>foo</code> is updated to be "Hello, World".</p>
<p>The example above only aims to highlight the usage of <code>do</code>, however usage of <code>null</code> and <code>mutable</code> are not encouraged. As a developer learns techniques in functional programming, usage of <code>null</code> or <code>mutable</code> is required less. The reason for the reduced usage is that concepts in functional programming, model computation differently resulting in code that is much clear in intent and fewer runtime errors. For a brief highlight of this see my post on <a title="//www.codingwithsam.com/net-none-none-none-or-exceptions/">How to turn runtime exceptions into compiler errors</a>.</p>
<h2>Dependencies with interfaces</h2>
<p>If you have read this far, we're almost at the point where all the knowledge has been laid out to build any standard view model. To complete this, you need to know how to pass in dependencies, notably interfaces.</p>
<p>An interface could be declared in C# or F# (The C# declaration would need to be in a different project). Here is one written in F#. There are no parenthesis after the name. Methods are declared with the <code>abstract</code> keyword and a type declaration.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="if">IService</span> <span class="o">=</span> 
    <span class="k">abstract</span> <span class="k">member</span> <span class="fn">Foo</span><span class="pn">:</span> <span class="rt">unit</span> <span class="k">-&gt;</span> <span class="vt">int</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>'Foo' is method that, when invoked, returns a single integer. With an interface declared, it can now be used. Here is a view model that is using the interface as a dependency. Simply declare the type and use it as you would any constructor argument.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel21</span><span class="pn">(</span><span class="id">foo</span><span class="pn">:</span> <span class="if">IService</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span><span class="pn">:</span> <span class="vt">int</span> <span class="o">=</span> <span class="fn">foo</span><span class="pn">.</span><span class="id">Foo</span><span class="pn">(</span><span class="pn">)</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>If you were to compare this to the C#/Java equivalent, you will see that a copy of the dependency does not need to be taken. No strange attributes, no local constructor parameters. No duplicate names.</p>
<p>Another key feature with these interfaces and view models is that they are fully compliant with any IOC framework. Register the interface (F# or C#), make sure the view model is appropriately named and enjoy everything working. These F# interfaces/classes generate very similar IL that the C# equivalent would output, you benefit from clearer code.</p>
<h2>Interfaces are optional</h2>
<p>The last example showed building a view model with a dependency through an interface. In large apps, both interfaces themselves and the number of interfaces a view model requires can get large. Many developers have found this can make things difficult to work with, and hard to refactor as the abstractions are no longer clear.</p>
<p>There is an alternative that many developers have already turned to. Replace the interface with just a function. For a full read up on this Scott Wlaschin provides the details: <a href="https://fsharpforfunandprofit.com/posts/dependency-injection-1/">Functional approaches to dependency injection</a>. To follow the approach that Scott talks about, all we need to do is pass in functions.</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">ViewModel22</span><span class="pn">(</span><span class="fn">foo</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="id">data</span> <span class="o">=</span> <span class="fn">foo</span><span class="pn">(</span><span class="pn">)</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span><span class="pn">:</span> <span class="vt">int</span> <span class="o">=</span> <span class="id">data</span>

<span class="k">let</span> <span class="id">vm</span> <span class="o">=</span> <span class="id">ViewModel</span><span class="pn">(</span><span class="k">fun</span> <span class="pn">(</span><span class="pn">)</span> <span class="k">-&gt;</span> <span class="n">42</span><span class="pn">)</span>  
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>As stated, no interface needed, just a function. Type inference checks the type for us so everything must be wired up correctly. Additionally, it must be noted that construction of the class must be done explicitly (Leave a comment if you know of an IOC container that can resolve functions). The result is that the code is now easier to read, especially for juniors since an IOC container is an advanced topic.</p>
<p>Using this functional approach will result in many functions passed into the view model. Incase it gets hard to keep track of those names and types, an alias for the type can be created to keep dependencies readable. Here's an example with a couple of dependencies:</p>
<table class="pre">
<tbody>
<tr>
<td class="lines">
<pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre>
</td>
<td class="snippet">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="rt">IFoo</span> <span class="o">=</span>  <span class="rt">unit</span> <span class="k">-&gt;</span> <span class="vt">int</span>
<span class="k">type</span> <span class="rt">IBar</span> <span class="o">=</span>  <span class="rt">unit</span> <span class="k">-&gt;</span> <span class="rt">string</span>
<span class="k">type</span> <span class="rt">ViewModel23</span><span class="pn">(</span><span class="fn">foo</span><span class="pn">:</span> <span class="rt">IFoo</span><span class="pn">,</span> <span class="fn">bar</span><span class="pn">:</span> <span class="rt">IBar</span><span class="pn">)</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="id">data</span> <span class="o">=</span> <span class="fn">foo</span><span class="pn">(</span><span class="pn">)</span> <span class="o">|&gt;</span> <span class="fn">string</span>
    <span class="k">let</span> <span class="id">message</span> <span class="o">=</span> <span class="fn">bar</span><span class="pn">(</span><span class="pn">)</span> <span class="o">+</span> <span class="s">" , "</span> <span class="o">+</span> <span class="id">data</span>
    <span class="k">member</span> <span class="id">this</span><span class="pn">.</span><span class="prop">Foo</span> <span class="o">=</span> <span class="id">message</span>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p>The type of <code>foo</code> and <code>bar</code> are declared explicitly, rather than being inferred by the compiler. As arguments to the class they now hve readable types as opposed to function types. The alias only affects readability, and will not help the compiler find errors.</p>
<p>So there you go, 23 absolutely useless view models. F# makes it easier and clear to create view models. The code is shorter and with a powerful compiler, both typing and errors can be reduced!</p>
<p>Your challenge: How many ways can you combine the 22 view models to make useful view models?</p>
<div id="fs1" class="tip">
<p>Multiple items<br />
type ViewModel1 =<br />
new : unit -&gt; ViewModel1<br />
member Foo : unit -&gt; int</p>
<p>Full name: creatingViewModels.ViewModel1</p>
<p>--------------------<br />
new : unit -&gt; ViewModel1</p>
</div>
<div id="fs2" class="tip">val this : ViewModel1</div>
<div id="fs3" class="tip">
<p>Multiple items<br />
type ViewModel2 =<br />
new : unit -&gt; ViewModel2</p>
<p>Full name: creatingViewModels.ViewModel2</p>
<p>--------------------<br />
new : unit -&gt; ViewModel2</p>
</div>
<div id="fs4" class="tip">val mutable _variable : int</div>
<div id="fs5" class="tip">
<p>Multiple items<br />
type ViewModel3 =<br />
new : unit -&gt; ViewModel3</p>
<p>Full name: creatingViewModels.ViewModel3</p>
<p>--------------------<br />
new : unit -&gt; ViewModel3</p>
</div>
<div id="fs6" class="tip">val _variable : int ref</div>
<div id="fs7" class="tip">
<p>Multiple items<br />
val ref : value:'T -&gt; 'T ref</p>
<p>Full name: Microsoft.FSharp.Core.Operators.ref</p>
<p>--------------------<br />
type 'T ref = Ref&lt;'T&gt;</p>
<p>Full name: Microsoft.FSharp.Core.ref&lt;_&gt;</p>
</div>
<div id="fs8" class="tip">
<p>Multiple items<br />
type ViewModel4 =<br />
new : unit -&gt; ViewModel4<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel4</p>
<p>--------------------<br />
new : unit -&gt; ViewModel4</p>
</div>
<div id="fs9" class="tip">val this : ViewModel4</div>
<div id="fs10" class="tip">
<p>Multiple items<br />
type ViewModel5 =<br />
new : unit -&gt; ViewModel5<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel5</p>
<p>--------------------<br />
new : unit -&gt; ViewModel5</p>
</div>
<div id="fs11" class="tip">val this : ViewModel5</div>
<div id="fs12" class="tip">
<p>Multiple items<br />
type ViewModel6 =<br />
new : unit -&gt; ViewModel6<br />
member Foo : int<br />
member Foo : int with set</p>
<p>Full name: creatingViewModels.ViewModel6</p>
<p>--------------------<br />
new : unit -&gt; ViewModel6</p>
</div>
<div id="fs13" class="tip">val this : ViewModel6</div>
<div id="fs14" class="tip">
<p>val set : elements:seq&lt;'T&gt; -&gt; Set&lt;'T&gt; (requires comparison)</p>
<p>Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.set</p>
</div>
<div id="fs15" class="tip">val value : int</div>
<div id="fs16" class="tip">
<p>Multiple items<br />
type ViewModel7 =<br />
new : unit -&gt; ViewModel7<br />
member Foo : int<br />
member Foo : int with set</p>
<p>Full name: creatingViewModels.ViewModel7</p>
<p>--------------------<br />
new : unit -&gt; ViewModel7</p>
</div>
<div id="fs17" class="tip">val this : ViewModel7</div>
<div id="fs18" class="tip">
<p>Multiple items<br />
type ViewModel8 =<br />
inherit obj<br />
new : unit -&gt; ViewModel8<br />
member Foo : 'a<br />
member Foo : 'a with set</p>
<p>Full name: creatingViewModels.ViewModel8</p>
<p>--------------------<br />
new : unit -&gt; ViewModel8</p>
</div>
<div id="fs19" class="tip">
<p>Multiple items<br />
type ViewModel9 =<br />
new : unit -&gt; ViewModel9<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel9</p>
<p>--------------------<br />
new : unit -&gt; ViewModel9</p>
</div>
<div id="fs20" class="tip">
<p>Multiple items<br />
type ViewModel10 =<br />
new : unit -&gt; ViewModel10<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel10</p>
<p>--------------------<br />
new : unit -&gt; ViewModel10</p>
</div>
<div id="fs21" class="tip">
<p>Multiple items<br />
type ViewModel11 =<br />
new : unit -&gt; ViewModel11<br />
member Foo : int<br />
member Foo : int with set</p>
<p>Full name: creatingViewModels.ViewModel11</p>
<p>--------------------<br />
new : unit -&gt; ViewModel11</p>
</div>
<div id="fs22" class="tip">
<p>Multiple items<br />
type ViewModel12 =<br />
new : unit -&gt; ViewModel12<br />
member private Foo : unit -&gt; int</p>
<p>Full name: creatingViewModels.ViewModel12</p>
<p>--------------------<br />
new : unit -&gt; ViewModel12</p>
</div>
<div id="fs23" class="tip">val this : ViewModel12</div>
<div id="fs24" class="tip">
<p>Multiple items<br />
type ViewModel13 =<br />
new : unit -&gt; ViewModel13</p>
<p>Full name: creatingViewModels.ViewModel13</p>
<p>--------------------<br />
new : unit -&gt; ViewModel13</p>
</div>
<div id="fs25" class="tip">val foo : int</div>
<div id="fs26" class="tip">val addTen : (int -&gt; int)</div>
<div id="fs27" class="tip">val x : int</div>
<div id="fs28" class="tip">val data : string</div>
<div id="fs29" class="tip">
<p>Multiple items<br />
val string : value:'T -&gt; string</p>
<p>Full name: Microsoft.FSharp.Core.Operators.string</p>
<p>--------------------<br />
type string = System.String</p>
<p>Full name: Microsoft.FSharp.Core.string</p>
</div>
<div id="fs30" class="tip">
<p>Multiple items<br />
type ViewModel14 =<br />
inherit obj<br />
new : unit -&gt; ViewModel14<br />
override Foo : unit -&gt; 'a</p>
<p>Full name: creatingViewModels.ViewModel14</p>
<p>--------------------<br />
new : unit -&gt; ViewModel14</p>
</div>
<div id="fs31" class="tip">
<p>Multiple items<br />
type ViewModel15 =<br />
new : foo:int -&gt; ViewModel15<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel15</p>
<p>--------------------<br />
new : foo:int -&gt; ViewModel15</p>
</div>
<div id="fs32" class="tip">
<p>Multiple items<br />
val int : value:'T -&gt; int (requires member op_Explicit)</p>
<p>Full name: Microsoft.FSharp.Core.Operators.int</p>
<p>--------------------<br />
type int = int32</p>
<p>Full name: Microsoft.FSharp.Core.int</p>
<p>--------------------<br />
type int&lt;'Measure&gt; = int</p>
<p>Full name: Microsoft.FSharp.Core.int&lt;_&gt;</p>
</div>
<div id="fs33" class="tip">val this : ViewModel15</div>
<div id="fs34" class="tip">
<p>Multiple items<br />
type ViewModel16 =<br />
new : foo:int -&gt; ViewModel16<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel16</p>
<p>--------------------<br />
new : foo:int -&gt; ViewModel16</p>
</div>
<div id="fs35" class="tip">val this : ViewModel16</div>
<div id="fs36" class="tip">
<p>Multiple items<br />
type ViewModel17 =<br />
new : foo:int -&gt; ViewModel17<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel17</p>
<p>--------------------<br />
new : foo:int -&gt; ViewModel17</p>
</div>
<div id="fs37" class="tip">val this : ViewModel17</div>
<div id="fs38" class="tip">
<p>Multiple items<br />
type ViewModel18 =<br />
new : foo:int -&gt; ViewModel18</p>
<p>Full name: creatingViewModels.ViewModel18</p>
<p>--------------------<br />
new : foo:int -&gt; ViewModel18</p>
</div>
<div id="fs39" class="tip">val fooPlusTen : unit</div>
<div id="fs40" class="tip">
<p>Multiple items<br />
type ViewModel19 =<br />
new : foo:int -&gt; ViewModel19</p>
<p>Full name: creatingViewModels.ViewModel19</p>
<p>--------------------<br />
new : foo:int -&gt; ViewModel19</p>
</div>
<div id="fs41" class="tip">val mutable _foo : int</div>
<div id="fs42" class="tip">
<p>Multiple items<br />
type ViewModel20 =<br />
new : unit -&gt; ViewModel20<br />
member Foo : unit -&gt; string</p>
<p>Full name: creatingViewModels.ViewModel20</p>
<p>--------------------<br />
new : unit -&gt; ViewModel20</p>
</div>
<div id="fs43" class="tip">val mutable foo : string</div>
<div id="fs44" class="tip">val this : ViewModel20</div>
<div id="fs45" class="tip">
<p>type IService =<br />
interface<br />
abstract member Foo : unit -&gt; int<br />
end</p>
<p>Full name: creatingViewModels.IService</p>
</div>
<div id="fs46" class="tip">
<p>abstract member IService.Foo : unit -&gt; int</p>
<p>Full name: creatingViewModels.IService.Foo</p>
</div>
<div id="fs47" class="tip">
<p>type unit = Unit</p>
<p>Full name: Microsoft.FSharp.Core.unit</p>
</div>
<div id="fs48" class="tip">
<p>Multiple items<br />
type ViewModel21 =<br />
new : foo:IService -&gt; ViewModel21<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel21</p>
<p>--------------------<br />
new : foo:IService -&gt; ViewModel21</p>
</div>
<div id="fs49" class="tip">val foo : IService</div>
<div id="fs50" class="tip">val this : ViewModel21</div>
<div id="fs51" class="tip">abstract member IService.Foo : unit -&gt; int</div>
<div id="fs52" class="tip">
<p>Multiple items<br />
type ViewModel22 =<br />
new : foo:(unit -&gt; int) -&gt; ViewModel22<br />
member Foo : int</p>
<p>Full name: creatingViewModels.ViewModel22</p>
<p>--------------------<br />
new : foo:(unit -&gt; int) -&gt; ViewModel22</p>
</div>
<div id="fs53" class="tip">val foo : (unit -&gt; int)</div>
<div id="fs54" class="tip">val data : int</div>
<div id="fs55" class="tip">val this : ViewModel22</div>
<div id="fs56" class="tip">
<p>val vm : obj</p>
<p>Full name: creatingViewModels.vm</p>
</div>
<div id="fs57" class="tip">
<p>type IFoo = unit -&gt; int</p>
<p>Full name: creatingViewModels.IFoo</p>
</div>
<div id="fs58" class="tip">
<p>type IBar = unit -&gt; string</p>
<p>Full name: creatingViewModels.IBar</p>
</div>
<div id="fs59" class="tip">
<p>Multiple items<br />
type ViewModel23 =<br />
new : foo:IFoo * bar:IBar -&gt; ViewModel23<br />
member Foo : string</p>
<p>Full name: creatingViewModels.ViewModel23</p>
<p>--------------------<br />
new : foo:IFoo * bar:IBar -&gt; ViewModel23</p>
</div>
<div id="fs60" class="tip">val foo : IFoo</div>
<div id="fs61" class="tip">val bar : IBar</div>
<div id="fs62" class="tip">val message : string</div>
<div id="fs63" class="tip">val this : ViewModel23</div>
